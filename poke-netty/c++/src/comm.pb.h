// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class NameValueSet;
class NameSpace;
class JobDesc;
class Ping;
class NameSpaceOperation;
class NameSpaceStatus;
class JobOperation;
class JobProposal;
class JobBid;
class JobStatus;
class RoutingPath;
class Header;
class Payload;
class Request;
class Heartbeat;
class Network;
class LeaderElection;
class Management;
class SignUp;

enum NameValueSet_NodeType {
  NameValueSet_NodeType_NODE = 1,
  NameValueSet_NodeType_VALUE = 2
};
bool NameValueSet_NodeType_IsValid(int value);
const NameValueSet_NodeType NameValueSet_NodeType_NodeType_MIN = NameValueSet_NodeType_NODE;
const NameValueSet_NodeType NameValueSet_NodeType_NodeType_MAX = NameValueSet_NodeType_VALUE;
const int NameValueSet_NodeType_NodeType_ARRAYSIZE = NameValueSet_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NameValueSet_NodeType_descriptor();
inline const ::std::string& NameValueSet_NodeType_Name(NameValueSet_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NameValueSet_NodeType_descriptor(), value);
}
inline bool NameValueSet_NodeType_Parse(
    const ::std::string& name, NameValueSet_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NameValueSet_NodeType>(
    NameValueSet_NodeType_descriptor(), name, value);
}
enum JobDesc_JobCode {
  JobDesc_JobCode_JOBUNKNOWN = 1,
  JobDesc_JobCode_JOBRECEIVED = 2,
  JobDesc_JobCode_JOBQUEUED = 3,
  JobDesc_JobCode_JOBRUNNING = 4,
  JobDesc_JobCode_JOBKILLED = 100,
  JobDesc_JobCode_JOBFAILED = 101
};
bool JobDesc_JobCode_IsValid(int value);
const JobDesc_JobCode JobDesc_JobCode_JobCode_MIN = JobDesc_JobCode_JOBUNKNOWN;
const JobDesc_JobCode JobDesc_JobCode_JobCode_MAX = JobDesc_JobCode_JOBFAILED;
const int JobDesc_JobCode_JobCode_ARRAYSIZE = JobDesc_JobCode_JobCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobDesc_JobCode_descriptor();
inline const ::std::string& JobDesc_JobCode_Name(JobDesc_JobCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobDesc_JobCode_descriptor(), value);
}
inline bool JobDesc_JobCode_Parse(
    const ::std::string& name, JobDesc_JobCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobDesc_JobCode>(
    JobDesc_JobCode_descriptor(), name, value);
}
enum NameSpaceOperation_SpaceAction {
  NameSpaceOperation_SpaceAction_ADDSPACE = 1,
  NameSpaceOperation_SpaceAction_UPDATESPACE = 2,
  NameSpaceOperation_SpaceAction_REMOVESPACE = 3,
  NameSpaceOperation_SpaceAction_LISTSPACES = 4
};
bool NameSpaceOperation_SpaceAction_IsValid(int value);
const NameSpaceOperation_SpaceAction NameSpaceOperation_SpaceAction_SpaceAction_MIN = NameSpaceOperation_SpaceAction_ADDSPACE;
const NameSpaceOperation_SpaceAction NameSpaceOperation_SpaceAction_SpaceAction_MAX = NameSpaceOperation_SpaceAction_LISTSPACES;
const int NameSpaceOperation_SpaceAction_SpaceAction_ARRAYSIZE = NameSpaceOperation_SpaceAction_SpaceAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* NameSpaceOperation_SpaceAction_descriptor();
inline const ::std::string& NameSpaceOperation_SpaceAction_Name(NameSpaceOperation_SpaceAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    NameSpaceOperation_SpaceAction_descriptor(), value);
}
inline bool NameSpaceOperation_SpaceAction_Parse(
    const ::std::string& name, NameSpaceOperation_SpaceAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NameSpaceOperation_SpaceAction>(
    NameSpaceOperation_SpaceAction_descriptor(), name, value);
}
enum JobOperation_JobAction {
  JobOperation_JobAction_ADDJOB = 1,
  JobOperation_JobAction_STOPJOB = 2,
  JobOperation_JobAction_REMOVEJOB = 3,
  JobOperation_JobAction_LISTJOBS = 4
};
bool JobOperation_JobAction_IsValid(int value);
const JobOperation_JobAction JobOperation_JobAction_JobAction_MIN = JobOperation_JobAction_ADDJOB;
const JobOperation_JobAction JobOperation_JobAction_JobAction_MAX = JobOperation_JobAction_LISTJOBS;
const int JobOperation_JobAction_JobAction_ARRAYSIZE = JobOperation_JobAction_JobAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobOperation_JobAction_descriptor();
inline const ::std::string& JobOperation_JobAction_Name(JobOperation_JobAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobOperation_JobAction_descriptor(), value);
}
inline bool JobOperation_JobAction_Parse(
    const ::std::string& name, JobOperation_JobAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobOperation_JobAction>(
    JobOperation_JobAction_descriptor(), name, value);
}
enum Header_Routing {
  Header_Routing_PING = 2,
  Header_Routing_NAMESPACES = 3,
  Header_Routing_JOBS = 4,
  Header_Routing_REPORTS = 10,
  Header_Routing_MANAGE = 100
};
bool Header_Routing_IsValid(int value);
const Header_Routing Header_Routing_Routing_MIN = Header_Routing_PING;
const Header_Routing Header_Routing_Routing_MAX = Header_Routing_MANAGE;
const int Header_Routing_Routing_ARRAYSIZE = Header_Routing_Routing_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_Routing_descriptor();
inline const ::std::string& Header_Routing_Name(Header_Routing value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_Routing_descriptor(), value);
}
inline bool Header_Routing_Parse(
    const ::std::string& name, Header_Routing* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_Routing>(
    Header_Routing_descriptor(), name, value);
}
enum Network_NetworkAction {
  Network_NetworkAction_NODEJOIN = 1,
  Network_NetworkAction_NODELEAVE = 2,
  Network_NetworkAction_NODEDEAD = 3,
  Network_NetworkAction_CREATEMAP = 55,
  Network_NetworkAction_ANNOUNCE = 56,
  Network_NetworkAction_SHUTDOWN = 999
};
bool Network_NetworkAction_IsValid(int value);
const Network_NetworkAction Network_NetworkAction_NetworkAction_MIN = Network_NetworkAction_NODEJOIN;
const Network_NetworkAction Network_NetworkAction_NetworkAction_MAX = Network_NetworkAction_SHUTDOWN;
const int Network_NetworkAction_NetworkAction_ARRAYSIZE = Network_NetworkAction_NetworkAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Network_NetworkAction_descriptor();
inline const ::std::string& Network_NetworkAction_Name(Network_NetworkAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Network_NetworkAction_descriptor(), value);
}
inline bool Network_NetworkAction_Parse(
    const ::std::string& name, Network_NetworkAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Network_NetworkAction>(
    Network_NetworkAction_descriptor(), name, value);
}
enum LeaderElection_VoteAction {
  LeaderElection_VoteAction_ELECTION = 1,
  LeaderElection_VoteAction_NOMINATE = 2,
  LeaderElection_VoteAction_ABSTAIN = 3,
  LeaderElection_VoteAction_DECLAREWINNER = 4,
  LeaderElection_VoteAction_DECLAREVOID = 5
};
bool LeaderElection_VoteAction_IsValid(int value);
const LeaderElection_VoteAction LeaderElection_VoteAction_VoteAction_MIN = LeaderElection_VoteAction_ELECTION;
const LeaderElection_VoteAction LeaderElection_VoteAction_VoteAction_MAX = LeaderElection_VoteAction_DECLAREVOID;
const int LeaderElection_VoteAction_VoteAction_ARRAYSIZE = LeaderElection_VoteAction_VoteAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* LeaderElection_VoteAction_descriptor();
inline const ::std::string& LeaderElection_VoteAction_Name(LeaderElection_VoteAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    LeaderElection_VoteAction_descriptor(), value);
}
inline bool LeaderElection_VoteAction_Parse(
    const ::std::string& name, LeaderElection_VoteAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeaderElection_VoteAction>(
    LeaderElection_VoteAction_descriptor(), name, value);
}
enum PokeStatus {
  UKNOWN = 1,
  SUCCESS = 2,
  NOFOUND = 100,
  NOINCOMPLETE = 101,
  NOAUTH = 102,
  NOCONNECTION = 103,
  NOREACHABLE = 104,
  NORESOURCE = 105,
  FAILURE = 199
};
bool PokeStatus_IsValid(int value);
const PokeStatus PokeStatus_MIN = UKNOWN;
const PokeStatus PokeStatus_MAX = FAILURE;
const int PokeStatus_ARRAYSIZE = PokeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PokeStatus_descriptor();
inline const ::std::string& PokeStatus_Name(PokeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PokeStatus_descriptor(), value);
}
inline bool PokeStatus_Parse(
    const ::std::string& name, PokeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PokeStatus>(
    PokeStatus_descriptor(), name, value);
}
// ===================================================================

class NameValueSet : public ::google::protobuf::Message {
 public:
  NameValueSet();
  virtual ~NameValueSet();

  NameValueSet(const NameValueSet& from);

  inline NameValueSet& operator=(const NameValueSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameValueSet& default_instance();

  void Swap(NameValueSet* other);

  // implements Message ----------------------------------------------

  NameValueSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameValueSet& from);
  void MergeFrom(const NameValueSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NameValueSet_NodeType NodeType;
  static const NodeType NODE = NameValueSet_NodeType_NODE;
  static const NodeType VALUE = NameValueSet_NodeType_VALUE;
  static inline bool NodeType_IsValid(int value) {
    return NameValueSet_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    NameValueSet_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    NameValueSet_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    NameValueSet_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return NameValueSet_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return NameValueSet_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return NameValueSet_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NameValueSet.NodeType node_type = 1;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 1;
  inline ::NameValueSet_NodeType node_type() const;
  inline void set_node_type(::NameValueSet_NodeType value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated .NameValueSet node = 4;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 4;
  inline const ::NameValueSet& node(int index) const;
  inline ::NameValueSet* mutable_node(int index);
  inline ::NameValueSet* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:NameValueSet)
 private:
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::NameValueSet > node_;
  int node_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameValueSet* default_instance_;
};
// -------------------------------------------------------------------

class NameSpace : public ::google::protobuf::Message {
 public:
  NameSpace();
  virtual ~NameSpace();

  NameSpace(const NameSpace& from);

  inline NameSpace& operator=(const NameSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpace& default_instance();

  void Swap(NameSpace* other);

  // implements Message ----------------------------------------------

  NameSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpace& from);
  void MergeFrom(const NameSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 ns_id = 2 [default = -1];
  inline bool has_ns_id() const;
  inline void clear_ns_id();
  static const int kNsIdFieldNumber = 2;
  inline ::google::protobuf::int64 ns_id() const;
  inline void set_ns_id(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional int64 created = 5;
  inline bool has_created() const;
  inline void clear_created();
  static const int kCreatedFieldNumber = 5;
  inline ::google::protobuf::int64 created() const;
  inline void set_created(::google::protobuf::int64 value);

  // optional int64 last_modified = 6;
  inline bool has_last_modified() const;
  inline void clear_last_modified();
  static const int kLastModifiedFieldNumber = 6;
  inline ::google::protobuf::int64 last_modified() const;
  inline void set_last_modified(::google::protobuf::int64 value);

  // optional string owner = 7;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 7;
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const char* value, size_t size);
  inline ::std::string* mutable_owner();
  inline ::std::string* release_owner();
  inline void set_allocated_owner(::std::string* owner);

  // optional .NameValueSet properties = 8;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 8;
  inline const ::NameValueSet& properties() const;
  inline ::NameValueSet* mutable_properties();
  inline ::NameValueSet* release_properties();
  inline void set_allocated_properties(::NameValueSet* properties);

  // @@protoc_insertion_point(class_scope:NameSpace)
 private:
  inline void set_has_ns_id();
  inline void clear_has_ns_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_created();
  inline void clear_has_created();
  inline void set_has_last_modified();
  inline void clear_has_last_modified();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_properties();
  inline void clear_has_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 ns_id_;
  ::std::string* name_;
  ::std::string* desc_;
  ::google::protobuf::int64 created_;
  ::google::protobuf::int64 last_modified_;
  ::std::string* owner_;
  ::NameValueSet* properties_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameSpace* default_instance_;
};
// -------------------------------------------------------------------

class JobDesc : public ::google::protobuf::Message {
 public:
  JobDesc();
  virtual ~JobDesc();

  JobDesc(const JobDesc& from);

  inline JobDesc& operator=(const JobDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobDesc& default_instance();

  void Swap(JobDesc* other);

  // implements Message ----------------------------------------------

  JobDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobDesc& from);
  void MergeFrom(const JobDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JobDesc_JobCode JobCode;
  static const JobCode JOBUNKNOWN = JobDesc_JobCode_JOBUNKNOWN;
  static const JobCode JOBRECEIVED = JobDesc_JobCode_JOBRECEIVED;
  static const JobCode JOBQUEUED = JobDesc_JobCode_JOBQUEUED;
  static const JobCode JOBRUNNING = JobDesc_JobCode_JOBRUNNING;
  static const JobCode JOBKILLED = JobDesc_JobCode_JOBKILLED;
  static const JobCode JOBFAILED = JobDesc_JobCode_JOBFAILED;
  static inline bool JobCode_IsValid(int value) {
    return JobDesc_JobCode_IsValid(value);
  }
  static const JobCode JobCode_MIN =
    JobDesc_JobCode_JobCode_MIN;
  static const JobCode JobCode_MAX =
    JobDesc_JobCode_JobCode_MAX;
  static const int JobCode_ARRAYSIZE =
    JobDesc_JobCode_JobCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JobCode_descriptor() {
    return JobDesc_JobCode_descriptor();
  }
  static inline const ::std::string& JobCode_Name(JobCode value) {
    return JobDesc_JobCode_Name(value);
  }
  static inline bool JobCode_Parse(const ::std::string& name,
      JobCode* value) {
    return JobDesc_JobCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  inline void set_allocated_name_space(::std::string* name_space);

  // required int64 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // required string job_id = 3;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required .JobDesc.JobCode status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::JobDesc_JobCode status() const;
  inline void set_status(::JobDesc_JobCode value);

  // optional .NameValueSet options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline const ::NameValueSet& options() const;
  inline ::NameValueSet* mutable_options();
  inline ::NameValueSet* release_options();
  inline void set_allocated_options(::NameValueSet* options);

  // @@protoc_insertion_point(class_scope:JobDesc)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_space_;
  ::google::protobuf::int64 owner_id_;
  ::std::string* job_id_;
  ::NameValueSet* options_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobDesc* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required string tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:Ping)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tag_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class NameSpaceOperation : public ::google::protobuf::Message {
 public:
  NameSpaceOperation();
  virtual ~NameSpaceOperation();

  NameSpaceOperation(const NameSpaceOperation& from);

  inline NameSpaceOperation& operator=(const NameSpaceOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpaceOperation& default_instance();

  void Swap(NameSpaceOperation* other);

  // implements Message ----------------------------------------------

  NameSpaceOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpaceOperation& from);
  void MergeFrom(const NameSpaceOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NameSpaceOperation_SpaceAction SpaceAction;
  static const SpaceAction ADDSPACE = NameSpaceOperation_SpaceAction_ADDSPACE;
  static const SpaceAction UPDATESPACE = NameSpaceOperation_SpaceAction_UPDATESPACE;
  static const SpaceAction REMOVESPACE = NameSpaceOperation_SpaceAction_REMOVESPACE;
  static const SpaceAction LISTSPACES = NameSpaceOperation_SpaceAction_LISTSPACES;
  static inline bool SpaceAction_IsValid(int value) {
    return NameSpaceOperation_SpaceAction_IsValid(value);
  }
  static const SpaceAction SpaceAction_MIN =
    NameSpaceOperation_SpaceAction_SpaceAction_MIN;
  static const SpaceAction SpaceAction_MAX =
    NameSpaceOperation_SpaceAction_SpaceAction_MAX;
  static const int SpaceAction_ARRAYSIZE =
    NameSpaceOperation_SpaceAction_SpaceAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpaceAction_descriptor() {
    return NameSpaceOperation_SpaceAction_descriptor();
  }
  static inline const ::std::string& SpaceAction_Name(SpaceAction value) {
    return NameSpaceOperation_SpaceAction_Name(value);
  }
  static inline bool SpaceAction_Parse(const ::std::string& name,
      SpaceAction* value) {
    return NameSpaceOperation_SpaceAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NameSpaceOperation.SpaceAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::NameSpaceOperation_SpaceAction action() const;
  inline void set_action(::NameSpaceOperation_SpaceAction value);

  // optional int64 ns_id = 2 [default = -1];
  inline bool has_ns_id() const;
  inline void clear_ns_id();
  static const int kNsIdFieldNumber = 2;
  inline ::google::protobuf::int64 ns_id() const;
  inline void set_ns_id(::google::protobuf::int64 value);

  // optional .NameSpace data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::NameSpace& data() const;
  inline ::NameSpace* mutable_data();
  inline ::NameSpace* release_data();
  inline void set_allocated_data(::NameSpace* data);

  // optional .NameValueSet options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::NameValueSet& options() const;
  inline ::NameValueSet* mutable_options();
  inline ::NameValueSet* release_options();
  inline void set_allocated_options(::NameValueSet* options);

  // @@protoc_insertion_point(class_scope:NameSpaceOperation)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_ns_id();
  inline void clear_has_ns_id();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 ns_id_;
  ::NameSpace* data_;
  ::NameValueSet* options_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameSpaceOperation* default_instance_;
};
// -------------------------------------------------------------------

class NameSpaceStatus : public ::google::protobuf::Message {
 public:
  NameSpaceStatus();
  virtual ~NameSpaceStatus();

  NameSpaceStatus(const NameSpaceStatus& from);

  inline NameSpaceStatus& operator=(const NameSpaceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpaceStatus& default_instance();

  void Swap(NameSpaceStatus* other);

  // implements Message ----------------------------------------------

  NameSpaceStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpaceStatus& from);
  void MergeFrom(const NameSpaceStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PokeStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::PokeStatus status() const;
  inline void set_status(::PokeStatus value);

  // repeated .NameSpace data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::NameSpace& data(int index) const;
  inline ::NameSpace* mutable_data(int index);
  inline ::NameSpace* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::NameSpace >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameSpace >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:NameSpaceStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NameSpace > data_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameSpaceStatus* default_instance_;
};
// -------------------------------------------------------------------

class JobOperation : public ::google::protobuf::Message {
 public:
  JobOperation();
  virtual ~JobOperation();

  JobOperation(const JobOperation& from);

  inline JobOperation& operator=(const JobOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobOperation& default_instance();

  void Swap(JobOperation* other);

  // implements Message ----------------------------------------------

  JobOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobOperation& from);
  void MergeFrom(const JobOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JobOperation_JobAction JobAction;
  static const JobAction ADDJOB = JobOperation_JobAction_ADDJOB;
  static const JobAction STOPJOB = JobOperation_JobAction_STOPJOB;
  static const JobAction REMOVEJOB = JobOperation_JobAction_REMOVEJOB;
  static const JobAction LISTJOBS = JobOperation_JobAction_LISTJOBS;
  static inline bool JobAction_IsValid(int value) {
    return JobOperation_JobAction_IsValid(value);
  }
  static const JobAction JobAction_MIN =
    JobOperation_JobAction_JobAction_MIN;
  static const JobAction JobAction_MAX =
    JobOperation_JobAction_JobAction_MAX;
  static const int JobAction_ARRAYSIZE =
    JobOperation_JobAction_JobAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JobAction_descriptor() {
    return JobOperation_JobAction_descriptor();
  }
  static inline const ::std::string& JobAction_Name(JobAction value) {
    return JobOperation_JobAction_Name(value);
  }
  static inline bool JobAction_Parse(const ::std::string& name,
      JobAction* value) {
    return JobOperation_JobAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .JobOperation.JobAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::JobOperation_JobAction action() const;
  inline void set_action(::JobOperation_JobAction value);

  // optional string job_id = 2;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 2;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // optional .JobDesc data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::JobDesc& data() const;
  inline ::JobDesc* mutable_data();
  inline ::JobDesc* release_data();
  inline void set_allocated_data(::JobDesc* data);

  // @@protoc_insertion_point(class_scope:JobOperation)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* job_id_;
  ::JobDesc* data_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobOperation* default_instance_;
};
// -------------------------------------------------------------------

class JobProposal : public ::google::protobuf::Message {
 public:
  JobProposal();
  virtual ~JobProposal();

  JobProposal(const JobProposal& from);

  inline JobProposal& operator=(const JobProposal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobProposal& default_instance();

  void Swap(JobProposal* other);

  // implements Message ----------------------------------------------

  JobProposal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobProposal& from);
  void MergeFrom(const JobProposal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  inline void set_allocated_name_space(::std::string* name_space);

  // required int64 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // required string job_id = 3;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required int32 weight = 4;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 4;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional .NameValueSet options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline const ::NameValueSet& options() const;
  inline ::NameValueSet* mutable_options();
  inline ::NameValueSet* release_options();
  inline void set_allocated_options(::NameValueSet* options);

  // @@protoc_insertion_point(class_scope:JobProposal)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_space_;
  ::google::protobuf::int64 owner_id_;
  ::std::string* job_id_;
  ::NameValueSet* options_;
  ::google::protobuf::int32 weight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobProposal* default_instance_;
};
// -------------------------------------------------------------------

class JobBid : public ::google::protobuf::Message {
 public:
  JobBid();
  virtual ~JobBid();

  JobBid(const JobBid& from);

  inline JobBid& operator=(const JobBid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobBid& default_instance();

  void Swap(JobBid* other);

  // implements Message ----------------------------------------------

  JobBid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobBid& from);
  void MergeFrom(const JobBid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  inline void set_allocated_name_space(::std::string* name_space);

  // required int64 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // required string job_id = 3;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required int32 bid = 4;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 4;
  inline ::google::protobuf::int32 bid() const;
  inline void set_bid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:JobBid)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_bid();
  inline void clear_has_bid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_space_;
  ::google::protobuf::int64 owner_id_;
  ::std::string* job_id_;
  ::google::protobuf::int32 bid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobBid* default_instance_;
};
// -------------------------------------------------------------------

class JobStatus : public ::google::protobuf::Message {
 public:
  JobStatus();
  virtual ~JobStatus();

  JobStatus(const JobStatus& from);

  inline JobStatus& operator=(const JobStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobStatus& default_instance();

  void Swap(JobStatus* other);

  // implements Message ----------------------------------------------

  JobStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobStatus& from);
  void MergeFrom(const JobStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required .PokeStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::PokeStatus status() const;
  inline void set_status(::PokeStatus value);

  // required .JobDesc.JobCode job_state = 3;
  inline bool has_job_state() const;
  inline void clear_job_state();
  static const int kJobStateFieldNumber = 3;
  inline ::JobDesc_JobCode job_state() const;
  inline void set_job_state(::JobDesc_JobCode value);

  // repeated .JobDesc data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::JobDesc& data(int index) const;
  inline ::JobDesc* mutable_data(int index);
  inline ::JobDesc* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::JobDesc >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::JobDesc >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:JobStatus)
 private:
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_job_state();
  inline void clear_has_job_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* job_id_;
  int status_;
  int job_state_;
  ::google::protobuf::RepeatedPtrField< ::JobDesc > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobStatus* default_instance_;
};
// -------------------------------------------------------------------

class RoutingPath : public ::google::protobuf::Message {
 public:
  RoutingPath();
  virtual ~RoutingPath();

  RoutingPath(const RoutingPath& from);

  inline RoutingPath& operator=(const RoutingPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingPath& default_instance();

  void Swap(RoutingPath* other);

  // implements Message ----------------------------------------------

  RoutingPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoutingPath& from);
  void MergeFrom(const RoutingPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const char* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // required int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RoutingPath)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_;
  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static RoutingPath* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Header_Routing Routing;
  static const Routing PING = Header_Routing_PING;
  static const Routing NAMESPACES = Header_Routing_NAMESPACES;
  static const Routing JOBS = Header_Routing_JOBS;
  static const Routing REPORTS = Header_Routing_REPORTS;
  static const Routing MANAGE = Header_Routing_MANAGE;
  static inline bool Routing_IsValid(int value) {
    return Header_Routing_IsValid(value);
  }
  static const Routing Routing_MIN =
    Header_Routing_Routing_MIN;
  static const Routing Routing_MAX =
    Header_Routing_Routing_MAX;
  static const int Routing_ARRAYSIZE =
    Header_Routing_Routing_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Routing_descriptor() {
    return Header_Routing_descriptor();
  }
  static inline const ::std::string& Routing_Name(Routing value) {
    return Header_Routing_Name(value);
  }
  static inline bool Routing_Parse(const ::std::string& name,
      Routing* value) {
    return Header_Routing_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Header.Routing routing_id = 1;
  inline bool has_routing_id() const;
  inline void clear_routing_id();
  static const int kRoutingIdFieldNumber = 1;
  inline ::Header_Routing routing_id() const;
  inline void set_routing_id(::Header_Routing value);

  // required string originator = 2;
  inline bool has_originator() const;
  inline void clear_originator();
  static const int kOriginatorFieldNumber = 2;
  inline const ::std::string& originator() const;
  inline void set_originator(const ::std::string& value);
  inline void set_originator(const char* value);
  inline void set_originator(const char* value, size_t size);
  inline ::std::string* mutable_originator();
  inline ::std::string* release_originator();
  inline void set_allocated_originator(::std::string* originator);

  // optional string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional .PokeStatus reply_code = 5;
  inline bool has_reply_code() const;
  inline void clear_reply_code();
  static const int kReplyCodeFieldNumber = 5;
  inline ::PokeStatus reply_code() const;
  inline void set_reply_code(::PokeStatus value);

  // optional string reply_msg = 6;
  inline bool has_reply_msg() const;
  inline void clear_reply_msg();
  static const int kReplyMsgFieldNumber = 6;
  inline const ::std::string& reply_msg() const;
  inline void set_reply_msg(const ::std::string& value);
  inline void set_reply_msg(const char* value);
  inline void set_reply_msg(const char* value, size_t size);
  inline ::std::string* mutable_reply_msg();
  inline ::std::string* release_reply_msg();
  inline void set_allocated_reply_msg(::std::string* reply_msg);

  // repeated .RoutingPath path = 7;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 7;
  inline const ::RoutingPath& path(int index) const;
  inline ::RoutingPath* mutable_path(int index);
  inline ::RoutingPath* add_path();
  inline const ::google::protobuf::RepeatedPtrField< ::RoutingPath >&
      path() const;
  inline ::google::protobuf::RepeatedPtrField< ::RoutingPath >*
      mutable_path();

  // optional string toNode = 8;
  inline bool has_tonode() const;
  inline void clear_tonode();
  static const int kToNodeFieldNumber = 8;
  inline const ::std::string& tonode() const;
  inline void set_tonode(const ::std::string& value);
  inline void set_tonode(const char* value);
  inline void set_tonode(const char* value, size_t size);
  inline ::std::string* mutable_tonode();
  inline ::std::string* release_tonode();
  inline void set_allocated_tonode(::std::string* tonode);

  // repeated .NameValueSet options = 9;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 9;
  inline const ::NameValueSet& options(int index) const;
  inline ::NameValueSet* mutable_options(int index);
  inline ::NameValueSet* add_options();
  inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
      options() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
      mutable_options();

  // @@protoc_insertion_point(class_scope:Header)
 private:
  inline void set_has_routing_id();
  inline void clear_has_routing_id();
  inline void set_has_originator();
  inline void clear_has_originator();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reply_code();
  inline void clear_has_reply_code();
  inline void set_has_reply_msg();
  inline void clear_has_reply_msg();
  inline void set_has_tonode();
  inline void clear_has_tonode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* originator_;
  ::std::string* tag_;
  int routing_id_;
  int reply_code_;
  ::google::protobuf::int64 time_;
  ::std::string* reply_msg_;
  ::google::protobuf::RepeatedPtrField< ::RoutingPath > path_;
  ::std::string* tonode_;
  ::google::protobuf::RepeatedPtrField< ::NameValueSet > options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Payload : public ::google::protobuf::Message {
 public:
  Payload();
  virtual ~Payload();

  Payload(const Payload& from);

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Payload& default_instance();

  void Swap(Payload* other);

  // implements Message ----------------------------------------------

  Payload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Ping ping = 1;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 1;
  inline const ::Ping& ping() const;
  inline ::Ping* mutable_ping();
  inline ::Ping* release_ping();
  inline void set_allocated_ping(::Ping* ping);

  // optional .NameSpaceOperation space_op = 2;
  inline bool has_space_op() const;
  inline void clear_space_op();
  static const int kSpaceOpFieldNumber = 2;
  inline const ::NameSpaceOperation& space_op() const;
  inline ::NameSpaceOperation* mutable_space_op();
  inline ::NameSpaceOperation* release_space_op();
  inline void set_allocated_space_op(::NameSpaceOperation* space_op);

  // optional .JobOperation job_op = 3;
  inline bool has_job_op() const;
  inline void clear_job_op();
  static const int kJobOpFieldNumber = 3;
  inline const ::JobOperation& job_op() const;
  inline ::JobOperation* mutable_job_op();
  inline ::JobOperation* release_job_op();
  inline void set_allocated_job_op(::JobOperation* job_op);

  // optional .JobStatus job_status = 6;
  inline bool has_job_status() const;
  inline void clear_job_status();
  static const int kJobStatusFieldNumber = 6;
  inline const ::JobStatus& job_status() const;
  inline ::JobStatus* mutable_job_status();
  inline ::JobStatus* release_job_status();
  inline void set_allocated_job_status(::JobStatus* job_status);

  // optional .NameSpaceStatus space_status = 7;
  inline bool has_space_status() const;
  inline void clear_space_status();
  static const int kSpaceStatusFieldNumber = 7;
  inline const ::NameSpaceStatus& space_status() const;
  inline ::NameSpaceStatus* mutable_space_status();
  inline ::NameSpaceStatus* release_space_status();
  inline void set_allocated_space_status(::NameSpaceStatus* space_status);

  // optional .SignUp signUp = 8;
  inline bool has_signup() const;
  inline void clear_signup();
  static const int kSignUpFieldNumber = 8;
  inline const ::SignUp& signup() const;
  inline ::SignUp* mutable_signup();
  inline ::SignUp* release_signup();
  inline void set_allocated_signup(::SignUp* signup);

  // @@protoc_insertion_point(class_scope:Payload)
 private:
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_space_op();
  inline void clear_has_space_op();
  inline void set_has_job_op();
  inline void clear_has_job_op();
  inline void set_has_job_status();
  inline void clear_has_job_status();
  inline void set_has_space_status();
  inline void clear_has_space_status();
  inline void set_has_signup();
  inline void clear_has_signup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Ping* ping_;
  ::NameSpaceOperation* space_op_;
  ::JobOperation* job_op_;
  ::JobStatus* job_status_;
  ::NameSpaceStatus* space_status_;
  ::SignUp* signup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Payload* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::Header& header() const;
  inline ::Header* mutable_header();
  inline ::Header* release_header();
  inline void set_allocated_header(::Header* header);

  // required .Payload body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::Payload& body() const;
  inline ::Payload* mutable_body();
  inline ::Payload* release_body();
  inline void set_allocated_body(::Payload* body);

  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Header* header_;
  ::Payload* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  Heartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required int64 time_ref = 2;
  inline bool has_time_ref() const;
  inline void clear_time_ref();
  static const int kTimeRefFieldNumber = 2;
  inline ::google::protobuf::int64 time_ref() const;
  inline void set_time_ref(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Heartbeat)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_time_ref();
  inline void clear_has_time_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_id_;
  ::google::protobuf::int64 time_ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::Message {
 public:
  Network();
  virtual ~Network();

  Network(const Network& from);

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Network& default_instance();

  void Swap(Network* other);

  // implements Message ----------------------------------------------

  Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Network_NetworkAction NetworkAction;
  static const NetworkAction NODEJOIN = Network_NetworkAction_NODEJOIN;
  static const NetworkAction NODELEAVE = Network_NetworkAction_NODELEAVE;
  static const NetworkAction NODEDEAD = Network_NetworkAction_NODEDEAD;
  static const NetworkAction CREATEMAP = Network_NetworkAction_CREATEMAP;
  static const NetworkAction ANNOUNCE = Network_NetworkAction_ANNOUNCE;
  static const NetworkAction SHUTDOWN = Network_NetworkAction_SHUTDOWN;
  static inline bool NetworkAction_IsValid(int value) {
    return Network_NetworkAction_IsValid(value);
  }
  static const NetworkAction NetworkAction_MIN =
    Network_NetworkAction_NetworkAction_MIN;
  static const NetworkAction NetworkAction_MAX =
    Network_NetworkAction_NetworkAction_MAX;
  static const int NetworkAction_ARRAYSIZE =
    Network_NetworkAction_NetworkAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NetworkAction_descriptor() {
    return Network_NetworkAction_descriptor();
  }
  static inline const ::std::string& NetworkAction_Name(NetworkAction value) {
    return Network_NetworkAction_Name(value);
  }
  static inline bool NetworkAction_Parse(const ::std::string& name,
      NetworkAction* value) {
    return Network_NetworkAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required .Network.NetworkAction action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::Network_NetworkAction action() const;
  inline void set_action(::Network_NetworkAction value);

  // @@protoc_insertion_point(class_scope:Network)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_id_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class LeaderElection : public ::google::protobuf::Message {
 public:
  LeaderElection();
  virtual ~LeaderElection();

  LeaderElection(const LeaderElection& from);

  inline LeaderElection& operator=(const LeaderElection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderElection& default_instance();

  void Swap(LeaderElection* other);

  // implements Message ----------------------------------------------

  LeaderElection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderElection& from);
  void MergeFrom(const LeaderElection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LeaderElection_VoteAction VoteAction;
  static const VoteAction ELECTION = LeaderElection_VoteAction_ELECTION;
  static const VoteAction NOMINATE = LeaderElection_VoteAction_NOMINATE;
  static const VoteAction ABSTAIN = LeaderElection_VoteAction_ABSTAIN;
  static const VoteAction DECLAREWINNER = LeaderElection_VoteAction_DECLAREWINNER;
  static const VoteAction DECLAREVOID = LeaderElection_VoteAction_DECLAREVOID;
  static inline bool VoteAction_IsValid(int value) {
    return LeaderElection_VoteAction_IsValid(value);
  }
  static const VoteAction VoteAction_MIN =
    LeaderElection_VoteAction_VoteAction_MIN;
  static const VoteAction VoteAction_MAX =
    LeaderElection_VoteAction_VoteAction_MAX;
  static const int VoteAction_ARRAYSIZE =
    LeaderElection_VoteAction_VoteAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VoteAction_descriptor() {
    return LeaderElection_VoteAction_descriptor();
  }
  static inline const ::std::string& VoteAction_Name(VoteAction value) {
    return LeaderElection_VoteAction_Name(value);
  }
  static inline bool VoteAction_Parse(const ::std::string& name,
      VoteAction* value) {
    return LeaderElection_VoteAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required string ballot_id = 2;
  inline bool has_ballot_id() const;
  inline void clear_ballot_id();
  static const int kBallotIdFieldNumber = 2;
  inline const ::std::string& ballot_id() const;
  inline void set_ballot_id(const ::std::string& value);
  inline void set_ballot_id(const char* value);
  inline void set_ballot_id(const char* value, size_t size);
  inline ::std::string* mutable_ballot_id();
  inline ::std::string* release_ballot_id();
  inline void set_allocated_ballot_id(::std::string* ballot_id);

  // required string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required .LeaderElection.VoteAction vote = 5;
  inline bool has_vote() const;
  inline void clear_vote();
  static const int kVoteFieldNumber = 5;
  inline ::LeaderElection_VoteAction vote() const;
  inline void set_vote(::LeaderElection_VoteAction value);

  // optional int64 expires = 6;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 6;
  inline ::google::protobuf::int64 expires() const;
  inline void set_expires(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:LeaderElection)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_ballot_id();
  inline void clear_has_ballot_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_vote();
  inline void clear_has_vote();
  inline void set_has_expires();
  inline void clear_has_expires();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_id_;
  ::std::string* ballot_id_;
  ::std::string* desc_;
  ::google::protobuf::int64 expires_;
  int vote_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static LeaderElection* default_instance_;
};
// -------------------------------------------------------------------

class Management : public ::google::protobuf::Message {
 public:
  Management();
  virtual ~Management();

  Management(const Management& from);

  inline Management& operator=(const Management& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Management& default_instance();

  void Swap(Management* other);

  // implements Message ----------------------------------------------

  Management* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Management& from);
  void MergeFrom(const Management& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Network graph = 1;
  inline bool has_graph() const;
  inline void clear_graph();
  static const int kGraphFieldNumber = 1;
  inline const ::Network& graph() const;
  inline ::Network* mutable_graph();
  inline ::Network* release_graph();
  inline void set_allocated_graph(::Network* graph);

  // optional .Heartbeat beat = 2;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 2;
  inline const ::Heartbeat& beat() const;
  inline ::Heartbeat* mutable_beat();
  inline ::Heartbeat* release_beat();
  inline void set_allocated_beat(::Heartbeat* beat);

  // optional .LeaderElection election = 3;
  inline bool has_election() const;
  inline void clear_election();
  static const int kElectionFieldNumber = 3;
  inline const ::LeaderElection& election() const;
  inline ::LeaderElection* mutable_election();
  inline ::LeaderElection* release_election();
  inline void set_allocated_election(::LeaderElection* election);

  // optional .JobProposal job_propose = 4;
  inline bool has_job_propose() const;
  inline void clear_job_propose();
  static const int kJobProposeFieldNumber = 4;
  inline const ::JobProposal& job_propose() const;
  inline ::JobProposal* mutable_job_propose();
  inline ::JobProposal* release_job_propose();
  inline void set_allocated_job_propose(::JobProposal* job_propose);

  // optional .JobBid job_bid = 5;
  inline bool has_job_bid() const;
  inline void clear_job_bid();
  static const int kJobBidFieldNumber = 5;
  inline const ::JobBid& job_bid() const;
  inline ::JobBid* mutable_job_bid();
  inline ::JobBid* release_job_bid();
  inline void set_allocated_job_bid(::JobBid* job_bid);

  // @@protoc_insertion_point(class_scope:Management)
 private:
  inline void set_has_graph();
  inline void clear_has_graph();
  inline void set_has_beat();
  inline void clear_has_beat();
  inline void set_has_election();
  inline void clear_has_election();
  inline void set_has_job_propose();
  inline void clear_has_job_propose();
  inline void set_has_job_bid();
  inline void clear_has_job_bid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Network* graph_;
  ::Heartbeat* beat_;
  ::LeaderElection* election_;
  ::JobProposal* job_propose_;
  ::JobBid* job_bid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Management* default_instance_;
};
// -------------------------------------------------------------------

class SignUp : public ::google::protobuf::Message {
 public:
  SignUp();
  virtual ~SignUp();

  SignUp(const SignUp& from);

  inline SignUp& operator=(const SignUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignUp& default_instance();

  void Swap(SignUp* other);

  // implements Message ----------------------------------------------

  SignUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignUp& from);
  void MergeFrom(const SignUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string fname = 3;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 3;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // required string lname = 4;
  inline bool has_lname() const;
  inline void clear_lname();
  static const int kLnameFieldNumber = 4;
  inline const ::std::string& lname() const;
  inline void set_lname(const ::std::string& value);
  inline void set_lname(const char* value);
  inline void set_lname(const char* value, size_t size);
  inline ::std::string* mutable_lname();
  inline ::std::string* release_lname();
  inline void set_allocated_lname(::std::string* lname);

  // @@protoc_insertion_point(class_scope:SignUp)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_lname();
  inline void clear_has_lname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* email_;
  ::std::string* password_;
  ::std::string* fname_;
  ::std::string* lname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static SignUp* default_instance_;
};
// ===================================================================


// ===================================================================

// NameValueSet

// required .NameValueSet.NodeType node_type = 1;
inline bool NameValueSet::has_node_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameValueSet::set_has_node_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameValueSet::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameValueSet::clear_node_type() {
  node_type_ = 1;
  clear_has_node_type();
}
inline ::NameValueSet_NodeType NameValueSet::node_type() const {
  return static_cast< ::NameValueSet_NodeType >(node_type_);
}
inline void NameValueSet::set_node_type(::NameValueSet_NodeType value) {
  assert(::NameValueSet_NodeType_IsValid(value));
  set_has_node_type();
  node_type_ = value;
}

// optional string name = 2;
inline bool NameValueSet::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameValueSet::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameValueSet::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameValueSet::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameValueSet::name() const {
  return *name_;
}
inline void NameValueSet::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValueSet::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValueSet::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValueSet::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameValueSet::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameValueSet::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 3;
inline bool NameValueSet::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameValueSet::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameValueSet::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameValueSet::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameValueSet::value() const {
  return *value_;
}
inline void NameValueSet::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValueSet::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValueSet::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValueSet::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameValueSet::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameValueSet::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .NameValueSet node = 4;
inline int NameValueSet::node_size() const {
  return node_.size();
}
inline void NameValueSet::clear_node() {
  node_.Clear();
}
inline const ::NameValueSet& NameValueSet::node(int index) const {
  return node_.Get(index);
}
inline ::NameValueSet* NameValueSet::mutable_node(int index) {
  return node_.Mutable(index);
}
inline ::NameValueSet* NameValueSet::add_node() {
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
NameValueSet::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
NameValueSet::mutable_node() {
  return &node_;
}

// -------------------------------------------------------------------

// NameSpace

// required int64 ns_id = 2 [default = -1];
inline bool NameSpace::has_ns_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpace::set_has_ns_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpace::clear_has_ns_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpace::clear_ns_id() {
  ns_id_ = GOOGLE_LONGLONG(-1);
  clear_has_ns_id();
}
inline ::google::protobuf::int64 NameSpace::ns_id() const {
  return ns_id_;
}
inline void NameSpace::set_ns_id(::google::protobuf::int64 value) {
  set_has_ns_id();
  ns_id_ = value;
}

// optional string name = 3;
inline bool NameSpace::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameSpace::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameSpace::name() const {
  return *name_;
}
inline void NameSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 4;
inline bool NameSpace::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameSpace::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameSpace::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameSpace::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& NameSpace::desc() const {
  return *desc_;
}
inline void NameSpace::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void NameSpace::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void NameSpace::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* NameSpace::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameSpace::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 created = 5;
inline bool NameSpace::has_created() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameSpace::set_has_created() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameSpace::clear_has_created() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameSpace::clear_created() {
  created_ = GOOGLE_LONGLONG(0);
  clear_has_created();
}
inline ::google::protobuf::int64 NameSpace::created() const {
  return created_;
}
inline void NameSpace::set_created(::google::protobuf::int64 value) {
  set_has_created();
  created_ = value;
}

// optional int64 last_modified = 6;
inline bool NameSpace::has_last_modified() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameSpace::set_has_last_modified() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameSpace::clear_has_last_modified() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameSpace::clear_last_modified() {
  last_modified_ = GOOGLE_LONGLONG(0);
  clear_has_last_modified();
}
inline ::google::protobuf::int64 NameSpace::last_modified() const {
  return last_modified_;
}
inline void NameSpace::set_last_modified(::google::protobuf::int64 value) {
  set_has_last_modified();
  last_modified_ = value;
}

// optional string owner = 7;
inline bool NameSpace::has_owner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NameSpace::set_has_owner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NameSpace::clear_has_owner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NameSpace::clear_owner() {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    owner_->clear();
  }
  clear_has_owner();
}
inline const ::std::string& NameSpace::owner() const {
  return *owner_;
}
inline void NameSpace::set_owner(const ::std::string& value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void NameSpace::set_owner(const char* value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void NameSpace::set_owner(const char* value, size_t size) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_owner() {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    owner_ = new ::std::string;
  }
  return owner_;
}
inline ::std::string* NameSpace::release_owner() {
  clear_has_owner();
  if (owner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_;
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameSpace::set_allocated_owner(::std::string* owner) {
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (owner) {
    set_has_owner();
    owner_ = owner;
  } else {
    clear_has_owner();
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .NameValueSet properties = 8;
inline bool NameSpace::has_properties() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NameSpace::set_has_properties() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NameSpace::clear_has_properties() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NameSpace::clear_properties() {
  if (properties_ != NULL) properties_->::NameValueSet::Clear();
  clear_has_properties();
}
inline const ::NameValueSet& NameSpace::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::NameValueSet* NameSpace::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) properties_ = new ::NameValueSet;
  return properties_;
}
inline ::NameValueSet* NameSpace::release_properties() {
  clear_has_properties();
  ::NameValueSet* temp = properties_;
  properties_ = NULL;
  return temp;
}
inline void NameSpace::set_allocated_properties(::NameValueSet* properties) {
  delete properties_;
  properties_ = properties;
  if (properties) {
    set_has_properties();
  } else {
    clear_has_properties();
  }
}

// -------------------------------------------------------------------

// JobDesc

// required string name_space = 1;
inline bool JobDesc::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobDesc::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobDesc::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobDesc::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& JobDesc::name_space() const {
  return *name_space_;
}
inline void JobDesc::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void JobDesc::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void JobDesc::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobDesc::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  return name_space_;
}
inline ::std::string* JobDesc::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobDesc::set_allocated_name_space(::std::string* name_space) {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    delete name_space_;
  }
  if (name_space) {
    set_has_name_space();
    name_space_ = name_space;
  } else {
    clear_has_name_space();
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 owner_id = 2;
inline bool JobDesc::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobDesc::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobDesc::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobDesc::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 JobDesc::owner_id() const {
  return owner_id_;
}
inline void JobDesc::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// required string job_id = 3;
inline bool JobDesc::has_job_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobDesc::set_has_job_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobDesc::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobDesc::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobDesc::job_id() const {
  return *job_id_;
}
inline void JobDesc::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobDesc::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobDesc::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobDesc::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}
inline ::std::string* JobDesc::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobDesc::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .JobDesc.JobCode status = 4;
inline bool JobDesc::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobDesc::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobDesc::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobDesc::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::JobDesc_JobCode JobDesc::status() const {
  return static_cast< ::JobDesc_JobCode >(status_);
}
inline void JobDesc::set_status(::JobDesc_JobCode value) {
  assert(::JobDesc_JobCode_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .NameValueSet options = 5;
inline bool JobDesc::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JobDesc::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JobDesc::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JobDesc::clear_options() {
  if (options_ != NULL) options_->::NameValueSet::Clear();
  clear_has_options();
}
inline const ::NameValueSet& JobDesc::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::NameValueSet* JobDesc::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::NameValueSet;
  return options_;
}
inline ::NameValueSet* JobDesc::release_options() {
  clear_has_options();
  ::NameValueSet* temp = options_;
  options_ = NULL;
  return temp;
}
inline void JobDesc::set_allocated_options(::NameValueSet* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// Ping

// required int32 number = 1;
inline bool Ping::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 Ping::number() const {
  return number_;
}
inline void Ping::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// required string tag = 2;
inline bool Ping::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Ping::tag() const {
  return *tag_;
}
inline void Ping::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Ping::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Ping::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ping::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Ping::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ping::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NameSpaceOperation

// required .NameSpaceOperation.SpaceAction action = 1;
inline bool NameSpaceOperation::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpaceOperation::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpaceOperation::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpaceOperation::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::NameSpaceOperation_SpaceAction NameSpaceOperation::action() const {
  return static_cast< ::NameSpaceOperation_SpaceAction >(action_);
}
inline void NameSpaceOperation::set_action(::NameSpaceOperation_SpaceAction value) {
  assert(::NameSpaceOperation_SpaceAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional int64 ns_id = 2 [default = -1];
inline bool NameSpaceOperation::has_ns_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameSpaceOperation::set_has_ns_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameSpaceOperation::clear_has_ns_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameSpaceOperation::clear_ns_id() {
  ns_id_ = GOOGLE_LONGLONG(-1);
  clear_has_ns_id();
}
inline ::google::protobuf::int64 NameSpaceOperation::ns_id() const {
  return ns_id_;
}
inline void NameSpaceOperation::set_ns_id(::google::protobuf::int64 value) {
  set_has_ns_id();
  ns_id_ = value;
}

// optional .NameSpace data = 3;
inline bool NameSpaceOperation::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameSpaceOperation::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameSpaceOperation::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameSpaceOperation::clear_data() {
  if (data_ != NULL) data_->::NameSpace::Clear();
  clear_has_data();
}
inline const ::NameSpace& NameSpaceOperation::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::NameSpace* NameSpaceOperation::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::NameSpace;
  return data_;
}
inline ::NameSpace* NameSpaceOperation::release_data() {
  clear_has_data();
  ::NameSpace* temp = data_;
  data_ = NULL;
  return temp;
}
inline void NameSpaceOperation::set_allocated_data(::NameSpace* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional .NameValueSet options = 4;
inline bool NameSpaceOperation::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameSpaceOperation::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameSpaceOperation::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameSpaceOperation::clear_options() {
  if (options_ != NULL) options_->::NameValueSet::Clear();
  clear_has_options();
}
inline const ::NameValueSet& NameSpaceOperation::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::NameValueSet* NameSpaceOperation::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::NameValueSet;
  return options_;
}
inline ::NameValueSet* NameSpaceOperation::release_options() {
  clear_has_options();
  ::NameValueSet* temp = options_;
  options_ = NULL;
  return temp;
}
inline void NameSpaceOperation::set_allocated_options(::NameValueSet* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// NameSpaceStatus

// required .PokeStatus status = 1;
inline bool NameSpaceStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpaceStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpaceStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpaceStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::PokeStatus NameSpaceStatus::status() const {
  return static_cast< ::PokeStatus >(status_);
}
inline void NameSpaceStatus::set_status(::PokeStatus value) {
  assert(::PokeStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// repeated .NameSpace data = 2;
inline int NameSpaceStatus::data_size() const {
  return data_.size();
}
inline void NameSpaceStatus::clear_data() {
  data_.Clear();
}
inline const ::NameSpace& NameSpaceStatus::data(int index) const {
  return data_.Get(index);
}
inline ::NameSpace* NameSpaceStatus::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::NameSpace* NameSpaceStatus::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameSpace >&
NameSpaceStatus::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameSpace >*
NameSpaceStatus::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// JobOperation

// required .JobOperation.JobAction action = 1;
inline bool JobOperation::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobOperation::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobOperation::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobOperation::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::JobOperation_JobAction JobOperation::action() const {
  return static_cast< ::JobOperation_JobAction >(action_);
}
inline void JobOperation::set_action(::JobOperation_JobAction value) {
  assert(::JobOperation_JobAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional string job_id = 2;
inline bool JobOperation::has_job_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobOperation::set_has_job_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobOperation::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobOperation::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobOperation::job_id() const {
  return *job_id_;
}
inline void JobOperation::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobOperation::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobOperation::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobOperation::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}
inline ::std::string* JobOperation::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobOperation::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .JobDesc data = 3;
inline bool JobOperation::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobOperation::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobOperation::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobOperation::clear_data() {
  if (data_ != NULL) data_->::JobDesc::Clear();
  clear_has_data();
}
inline const ::JobDesc& JobOperation::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::JobDesc* JobOperation::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::JobDesc;
  return data_;
}
inline ::JobDesc* JobOperation::release_data() {
  clear_has_data();
  ::JobDesc* temp = data_;
  data_ = NULL;
  return temp;
}
inline void JobOperation::set_allocated_data(::JobDesc* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// JobProposal

// required string name_space = 1;
inline bool JobProposal::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobProposal::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobProposal::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobProposal::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& JobProposal::name_space() const {
  return *name_space_;
}
inline void JobProposal::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void JobProposal::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void JobProposal::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobProposal::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  return name_space_;
}
inline ::std::string* JobProposal::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobProposal::set_allocated_name_space(::std::string* name_space) {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    delete name_space_;
  }
  if (name_space) {
    set_has_name_space();
    name_space_ = name_space;
  } else {
    clear_has_name_space();
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 owner_id = 2;
inline bool JobProposal::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobProposal::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobProposal::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobProposal::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 JobProposal::owner_id() const {
  return owner_id_;
}
inline void JobProposal::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// required string job_id = 3;
inline bool JobProposal::has_job_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobProposal::set_has_job_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobProposal::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobProposal::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobProposal::job_id() const {
  return *job_id_;
}
inline void JobProposal::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobProposal::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobProposal::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobProposal::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}
inline ::std::string* JobProposal::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobProposal::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 weight = 4;
inline bool JobProposal::has_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobProposal::set_has_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobProposal::clear_has_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobProposal::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 JobProposal::weight() const {
  return weight_;
}
inline void JobProposal::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
}

// optional .NameValueSet options = 5;
inline bool JobProposal::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JobProposal::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JobProposal::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JobProposal::clear_options() {
  if (options_ != NULL) options_->::NameValueSet::Clear();
  clear_has_options();
}
inline const ::NameValueSet& JobProposal::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::NameValueSet* JobProposal::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::NameValueSet;
  return options_;
}
inline ::NameValueSet* JobProposal::release_options() {
  clear_has_options();
  ::NameValueSet* temp = options_;
  options_ = NULL;
  return temp;
}
inline void JobProposal::set_allocated_options(::NameValueSet* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// JobBid

// required string name_space = 1;
inline bool JobBid::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobBid::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobBid::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobBid::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& JobBid::name_space() const {
  return *name_space_;
}
inline void JobBid::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void JobBid::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void JobBid::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobBid::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  return name_space_;
}
inline ::std::string* JobBid::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobBid::set_allocated_name_space(::std::string* name_space) {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    delete name_space_;
  }
  if (name_space) {
    set_has_name_space();
    name_space_ = name_space;
  } else {
    clear_has_name_space();
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 owner_id = 2;
inline bool JobBid::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobBid::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobBid::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobBid::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 JobBid::owner_id() const {
  return owner_id_;
}
inline void JobBid::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// required string job_id = 3;
inline bool JobBid::has_job_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobBid::set_has_job_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobBid::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobBid::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobBid::job_id() const {
  return *job_id_;
}
inline void JobBid::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobBid::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobBid::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobBid::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}
inline ::std::string* JobBid::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobBid::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 bid = 4;
inline bool JobBid::has_bid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobBid::set_has_bid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobBid::clear_has_bid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobBid::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline ::google::protobuf::int32 JobBid::bid() const {
  return bid_;
}
inline void JobBid::set_bid(::google::protobuf::int32 value) {
  set_has_bid();
  bid_ = value;
}

// -------------------------------------------------------------------

// JobStatus

// required string job_id = 1;
inline bool JobStatus::has_job_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobStatus::set_has_job_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobStatus::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobStatus::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobStatus::job_id() const {
  return *job_id_;
}
inline void JobStatus::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobStatus::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobStatus::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobStatus::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}
inline ::std::string* JobStatus::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobStatus::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::kEmptyString) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .PokeStatus status = 2;
inline bool JobStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::PokeStatus JobStatus::status() const {
  return static_cast< ::PokeStatus >(status_);
}
inline void JobStatus::set_status(::PokeStatus value) {
  assert(::PokeStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required .JobDesc.JobCode job_state = 3;
inline bool JobStatus::has_job_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobStatus::set_has_job_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobStatus::clear_has_job_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobStatus::clear_job_state() {
  job_state_ = 1;
  clear_has_job_state();
}
inline ::JobDesc_JobCode JobStatus::job_state() const {
  return static_cast< ::JobDesc_JobCode >(job_state_);
}
inline void JobStatus::set_job_state(::JobDesc_JobCode value) {
  assert(::JobDesc_JobCode_IsValid(value));
  set_has_job_state();
  job_state_ = value;
}

// repeated .JobDesc data = 4;
inline int JobStatus::data_size() const {
  return data_.size();
}
inline void JobStatus::clear_data() {
  data_.Clear();
}
inline const ::JobDesc& JobStatus::data(int index) const {
  return data_.Get(index);
}
inline ::JobDesc* JobStatus::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::JobDesc* JobStatus::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::JobDesc >&
JobStatus::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::JobDesc >*
JobStatus::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// RoutingPath

// required string node = 1;
inline bool RoutingPath::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingPath::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingPath::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingPath::clear_node() {
  if (node_ != &::google::protobuf::internal::kEmptyString) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& RoutingPath::node() const {
  return *node_;
}
inline void RoutingPath::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RoutingPath::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RoutingPath::set_node(const char* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutingPath::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  return node_;
}
inline ::std::string* RoutingPath::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoutingPath::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::kEmptyString) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 time = 2;
inline bool RoutingPath::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingPath::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingPath::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingPath::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 RoutingPath::time() const {
  return time_;
}
inline void RoutingPath::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Header

// required .Header.Routing routing_id = 1;
inline bool Header::has_routing_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_routing_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_routing_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_routing_id() {
  routing_id_ = 2;
  clear_has_routing_id();
}
inline ::Header_Routing Header::routing_id() const {
  return static_cast< ::Header_Routing >(routing_id_);
}
inline void Header::set_routing_id(::Header_Routing value) {
  assert(::Header_Routing_IsValid(value));
  set_has_routing_id();
  routing_id_ = value;
}

// required string originator = 2;
inline bool Header::has_originator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_originator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_originator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_originator() {
  if (originator_ != &::google::protobuf::internal::kEmptyString) {
    originator_->clear();
  }
  clear_has_originator();
}
inline const ::std::string& Header::originator() const {
  return *originator_;
}
inline void Header::set_originator(const ::std::string& value) {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  originator_->assign(value);
}
inline void Header::set_originator(const char* value) {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  originator_->assign(value);
}
inline void Header::set_originator(const char* value, size_t size) {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  originator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_originator() {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  return originator_;
}
inline ::std::string* Header::release_originator() {
  clear_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = originator_;
    originator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_originator(::std::string* originator) {
  if (originator_ != &::google::protobuf::internal::kEmptyString) {
    delete originator_;
  }
  if (originator) {
    set_has_originator();
    originator_ = originator;
  } else {
    clear_has_originator();
    originator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tag = 3;
inline bool Header::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Header::tag() const {
  return *tag_;
}
inline void Header::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Header::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Header::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Header::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 4;
inline bool Header::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Header::time() const {
  return time_;
}
inline void Header::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional .PokeStatus reply_code = 5;
inline bool Header::has_reply_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_reply_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_reply_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_reply_code() {
  reply_code_ = 1;
  clear_has_reply_code();
}
inline ::PokeStatus Header::reply_code() const {
  return static_cast< ::PokeStatus >(reply_code_);
}
inline void Header::set_reply_code(::PokeStatus value) {
  assert(::PokeStatus_IsValid(value));
  set_has_reply_code();
  reply_code_ = value;
}

// optional string reply_msg = 6;
inline bool Header::has_reply_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_reply_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_reply_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_reply_msg() {
  if (reply_msg_ != &::google::protobuf::internal::kEmptyString) {
    reply_msg_->clear();
  }
  clear_has_reply_msg();
}
inline const ::std::string& Header::reply_msg() const {
  return *reply_msg_;
}
inline void Header::set_reply_msg(const ::std::string& value) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(value);
}
inline void Header::set_reply_msg(const char* value) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(value);
}
inline void Header::set_reply_msg(const char* value, size_t size) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_reply_msg() {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  return reply_msg_;
}
inline ::std::string* Header::release_reply_msg() {
  clear_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reply_msg_;
    reply_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_reply_msg(::std::string* reply_msg) {
  if (reply_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete reply_msg_;
  }
  if (reply_msg) {
    set_has_reply_msg();
    reply_msg_ = reply_msg;
  } else {
    clear_has_reply_msg();
    reply_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .RoutingPath path = 7;
inline int Header::path_size() const {
  return path_.size();
}
inline void Header::clear_path() {
  path_.Clear();
}
inline const ::RoutingPath& Header::path(int index) const {
  return path_.Get(index);
}
inline ::RoutingPath* Header::mutable_path(int index) {
  return path_.Mutable(index);
}
inline ::RoutingPath* Header::add_path() {
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RoutingPath >&
Header::path() const {
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::RoutingPath >*
Header::mutable_path() {
  return &path_;
}

// optional string toNode = 8;
inline bool Header::has_tonode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_tonode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_tonode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_tonode() {
  if (tonode_ != &::google::protobuf::internal::kEmptyString) {
    tonode_->clear();
  }
  clear_has_tonode();
}
inline const ::std::string& Header::tonode() const {
  return *tonode_;
}
inline void Header::set_tonode(const ::std::string& value) {
  set_has_tonode();
  if (tonode_ == &::google::protobuf::internal::kEmptyString) {
    tonode_ = new ::std::string;
  }
  tonode_->assign(value);
}
inline void Header::set_tonode(const char* value) {
  set_has_tonode();
  if (tonode_ == &::google::protobuf::internal::kEmptyString) {
    tonode_ = new ::std::string;
  }
  tonode_->assign(value);
}
inline void Header::set_tonode(const char* value, size_t size) {
  set_has_tonode();
  if (tonode_ == &::google::protobuf::internal::kEmptyString) {
    tonode_ = new ::std::string;
  }
  tonode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_tonode() {
  set_has_tonode();
  if (tonode_ == &::google::protobuf::internal::kEmptyString) {
    tonode_ = new ::std::string;
  }
  return tonode_;
}
inline ::std::string* Header::release_tonode() {
  clear_has_tonode();
  if (tonode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tonode_;
    tonode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_tonode(::std::string* tonode) {
  if (tonode_ != &::google::protobuf::internal::kEmptyString) {
    delete tonode_;
  }
  if (tonode) {
    set_has_tonode();
    tonode_ = tonode;
  } else {
    clear_has_tonode();
    tonode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .NameValueSet options = 9;
inline int Header::options_size() const {
  return options_.size();
}
inline void Header::clear_options() {
  options_.Clear();
}
inline const ::NameValueSet& Header::options(int index) const {
  return options_.Get(index);
}
inline ::NameValueSet* Header::mutable_options(int index) {
  return options_.Mutable(index);
}
inline ::NameValueSet* Header::add_options() {
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
Header::options() const {
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
Header::mutable_options() {
  return &options_;
}

// -------------------------------------------------------------------

// Payload

// optional .Ping ping = 1;
inline bool Payload::has_ping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Payload::set_has_ping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Payload::clear_has_ping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Payload::clear_ping() {
  if (ping_ != NULL) ping_->::Ping::Clear();
  clear_has_ping();
}
inline const ::Ping& Payload::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::Ping* Payload::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::Ping;
  return ping_;
}
inline ::Ping* Payload::release_ping() {
  clear_has_ping();
  ::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void Payload::set_allocated_ping(::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
}

// optional .NameSpaceOperation space_op = 2;
inline bool Payload::has_space_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Payload::set_has_space_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Payload::clear_has_space_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Payload::clear_space_op() {
  if (space_op_ != NULL) space_op_->::NameSpaceOperation::Clear();
  clear_has_space_op();
}
inline const ::NameSpaceOperation& Payload::space_op() const {
  return space_op_ != NULL ? *space_op_ : *default_instance_->space_op_;
}
inline ::NameSpaceOperation* Payload::mutable_space_op() {
  set_has_space_op();
  if (space_op_ == NULL) space_op_ = new ::NameSpaceOperation;
  return space_op_;
}
inline ::NameSpaceOperation* Payload::release_space_op() {
  clear_has_space_op();
  ::NameSpaceOperation* temp = space_op_;
  space_op_ = NULL;
  return temp;
}
inline void Payload::set_allocated_space_op(::NameSpaceOperation* space_op) {
  delete space_op_;
  space_op_ = space_op;
  if (space_op) {
    set_has_space_op();
  } else {
    clear_has_space_op();
  }
}

// optional .JobOperation job_op = 3;
inline bool Payload::has_job_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Payload::set_has_job_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Payload::clear_has_job_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Payload::clear_job_op() {
  if (job_op_ != NULL) job_op_->::JobOperation::Clear();
  clear_has_job_op();
}
inline const ::JobOperation& Payload::job_op() const {
  return job_op_ != NULL ? *job_op_ : *default_instance_->job_op_;
}
inline ::JobOperation* Payload::mutable_job_op() {
  set_has_job_op();
  if (job_op_ == NULL) job_op_ = new ::JobOperation;
  return job_op_;
}
inline ::JobOperation* Payload::release_job_op() {
  clear_has_job_op();
  ::JobOperation* temp = job_op_;
  job_op_ = NULL;
  return temp;
}
inline void Payload::set_allocated_job_op(::JobOperation* job_op) {
  delete job_op_;
  job_op_ = job_op;
  if (job_op) {
    set_has_job_op();
  } else {
    clear_has_job_op();
  }
}

// optional .JobStatus job_status = 6;
inline bool Payload::has_job_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Payload::set_has_job_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Payload::clear_has_job_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Payload::clear_job_status() {
  if (job_status_ != NULL) job_status_->::JobStatus::Clear();
  clear_has_job_status();
}
inline const ::JobStatus& Payload::job_status() const {
  return job_status_ != NULL ? *job_status_ : *default_instance_->job_status_;
}
inline ::JobStatus* Payload::mutable_job_status() {
  set_has_job_status();
  if (job_status_ == NULL) job_status_ = new ::JobStatus;
  return job_status_;
}
inline ::JobStatus* Payload::release_job_status() {
  clear_has_job_status();
  ::JobStatus* temp = job_status_;
  job_status_ = NULL;
  return temp;
}
inline void Payload::set_allocated_job_status(::JobStatus* job_status) {
  delete job_status_;
  job_status_ = job_status;
  if (job_status) {
    set_has_job_status();
  } else {
    clear_has_job_status();
  }
}

// optional .NameSpaceStatus space_status = 7;
inline bool Payload::has_space_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Payload::set_has_space_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Payload::clear_has_space_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Payload::clear_space_status() {
  if (space_status_ != NULL) space_status_->::NameSpaceStatus::Clear();
  clear_has_space_status();
}
inline const ::NameSpaceStatus& Payload::space_status() const {
  return space_status_ != NULL ? *space_status_ : *default_instance_->space_status_;
}
inline ::NameSpaceStatus* Payload::mutable_space_status() {
  set_has_space_status();
  if (space_status_ == NULL) space_status_ = new ::NameSpaceStatus;
  return space_status_;
}
inline ::NameSpaceStatus* Payload::release_space_status() {
  clear_has_space_status();
  ::NameSpaceStatus* temp = space_status_;
  space_status_ = NULL;
  return temp;
}
inline void Payload::set_allocated_space_status(::NameSpaceStatus* space_status) {
  delete space_status_;
  space_status_ = space_status;
  if (space_status) {
    set_has_space_status();
  } else {
    clear_has_space_status();
  }
}

// optional .SignUp signUp = 8;
inline bool Payload::has_signup() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Payload::set_has_signup() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Payload::clear_has_signup() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Payload::clear_signup() {
  if (signup_ != NULL) signup_->::SignUp::Clear();
  clear_has_signup();
}
inline const ::SignUp& Payload::signup() const {
  return signup_ != NULL ? *signup_ : *default_instance_->signup_;
}
inline ::SignUp* Payload::mutable_signup() {
  set_has_signup();
  if (signup_ == NULL) signup_ = new ::SignUp;
  return signup_;
}
inline ::SignUp* Payload::release_signup() {
  clear_has_signup();
  ::SignUp* temp = signup_;
  signup_ = NULL;
  return temp;
}
inline void Payload::set_allocated_signup(::SignUp* signup) {
  delete signup_;
  signup_ = signup;
  if (signup) {
    set_has_signup();
  } else {
    clear_has_signup();
  }
}

// -------------------------------------------------------------------

// Request

// required .Header header = 1;
inline bool Request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& Request::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* Request::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Header;
  return header_;
}
inline ::Header* Request::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Request::set_allocated_header(::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required .Payload body = 2;
inline bool Request::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_body() {
  if (body_ != NULL) body_->::Payload::Clear();
  clear_has_body();
}
inline const ::Payload& Request::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::Payload* Request::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::Payload;
  return body_;
}
inline ::Payload* Request::release_body() {
  clear_has_body();
  ::Payload* temp = body_;
  body_ = NULL;
  return temp;
}
inline void Request::set_allocated_body(::Payload* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}

// -------------------------------------------------------------------

// Heartbeat

// required string node_id = 1;
inline bool Heartbeat::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& Heartbeat::node_id() const {
  return *node_id_;
}
inline void Heartbeat::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Heartbeat::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Heartbeat::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Heartbeat::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* Heartbeat::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Heartbeat::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 time_ref = 2;
inline bool Heartbeat::has_time_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heartbeat::set_has_time_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heartbeat::clear_has_time_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heartbeat::clear_time_ref() {
  time_ref_ = GOOGLE_LONGLONG(0);
  clear_has_time_ref();
}
inline ::google::protobuf::int64 Heartbeat::time_ref() const {
  return time_ref_;
}
inline void Heartbeat::set_time_ref(::google::protobuf::int64 value) {
  set_has_time_ref();
  time_ref_ = value;
}

// -------------------------------------------------------------------

// Network

// required string node_id = 1;
inline bool Network::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& Network::node_id() const {
  return *node_id_;
}
inline void Network::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Network::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Network::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* Network::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Network::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Network.NetworkAction action = 2;
inline bool Network::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::Network_NetworkAction Network::action() const {
  return static_cast< ::Network_NetworkAction >(action_);
}
inline void Network::set_action(::Network_NetworkAction value) {
  assert(::Network_NetworkAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// LeaderElection

// required string node_id = 1;
inline bool LeaderElection::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderElection::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderElection::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderElection::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& LeaderElection::node_id() const {
  return *node_id_;
}
inline void LeaderElection::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void LeaderElection::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void LeaderElection::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderElection::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* LeaderElection::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderElection::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ballot_id = 2;
inline bool LeaderElection::has_ballot_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderElection::set_has_ballot_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderElection::clear_has_ballot_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderElection::clear_ballot_id() {
  if (ballot_id_ != &::google::protobuf::internal::kEmptyString) {
    ballot_id_->clear();
  }
  clear_has_ballot_id();
}
inline const ::std::string& LeaderElection::ballot_id() const {
  return *ballot_id_;
}
inline void LeaderElection::set_ballot_id(const ::std::string& value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::kEmptyString) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
}
inline void LeaderElection::set_ballot_id(const char* value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::kEmptyString) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
}
inline void LeaderElection::set_ballot_id(const char* value, size_t size) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::kEmptyString) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderElection::mutable_ballot_id() {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::kEmptyString) {
    ballot_id_ = new ::std::string;
  }
  return ballot_id_;
}
inline ::std::string* LeaderElection::release_ballot_id() {
  clear_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ballot_id_;
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderElection::set_allocated_ballot_id(::std::string* ballot_id) {
  if (ballot_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ballot_id_;
  }
  if (ballot_id) {
    set_has_ballot_id();
    ballot_id_ = ballot_id;
  } else {
    clear_has_ballot_id();
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string desc = 4;
inline bool LeaderElection::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderElection::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderElection::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderElection::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& LeaderElection::desc() const {
  return *desc_;
}
inline void LeaderElection::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LeaderElection::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LeaderElection::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderElection::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* LeaderElection::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderElection::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .LeaderElection.VoteAction vote = 5;
inline bool LeaderElection::has_vote() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaderElection::set_has_vote() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaderElection::clear_has_vote() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaderElection::clear_vote() {
  vote_ = 1;
  clear_has_vote();
}
inline ::LeaderElection_VoteAction LeaderElection::vote() const {
  return static_cast< ::LeaderElection_VoteAction >(vote_);
}
inline void LeaderElection::set_vote(::LeaderElection_VoteAction value) {
  assert(::LeaderElection_VoteAction_IsValid(value));
  set_has_vote();
  vote_ = value;
}

// optional int64 expires = 6;
inline bool LeaderElection::has_expires() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LeaderElection::set_has_expires() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LeaderElection::clear_has_expires() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LeaderElection::clear_expires() {
  expires_ = GOOGLE_LONGLONG(0);
  clear_has_expires();
}
inline ::google::protobuf::int64 LeaderElection::expires() const {
  return expires_;
}
inline void LeaderElection::set_expires(::google::protobuf::int64 value) {
  set_has_expires();
  expires_ = value;
}

// -------------------------------------------------------------------

// Management

// optional .Network graph = 1;
inline bool Management::has_graph() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Management::set_has_graph() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Management::clear_has_graph() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Management::clear_graph() {
  if (graph_ != NULL) graph_->::Network::Clear();
  clear_has_graph();
}
inline const ::Network& Management::graph() const {
  return graph_ != NULL ? *graph_ : *default_instance_->graph_;
}
inline ::Network* Management::mutable_graph() {
  set_has_graph();
  if (graph_ == NULL) graph_ = new ::Network;
  return graph_;
}
inline ::Network* Management::release_graph() {
  clear_has_graph();
  ::Network* temp = graph_;
  graph_ = NULL;
  return temp;
}
inline void Management::set_allocated_graph(::Network* graph) {
  delete graph_;
  graph_ = graph;
  if (graph) {
    set_has_graph();
  } else {
    clear_has_graph();
  }
}

// optional .Heartbeat beat = 2;
inline bool Management::has_beat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Management::set_has_beat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Management::clear_has_beat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Management::clear_beat() {
  if (beat_ != NULL) beat_->::Heartbeat::Clear();
  clear_has_beat();
}
inline const ::Heartbeat& Management::beat() const {
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::Heartbeat* Management::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::Heartbeat;
  return beat_;
}
inline ::Heartbeat* Management::release_beat() {
  clear_has_beat();
  ::Heartbeat* temp = beat_;
  beat_ = NULL;
  return temp;
}
inline void Management::set_allocated_beat(::Heartbeat* beat) {
  delete beat_;
  beat_ = beat;
  if (beat) {
    set_has_beat();
  } else {
    clear_has_beat();
  }
}

// optional .LeaderElection election = 3;
inline bool Management::has_election() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Management::set_has_election() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Management::clear_has_election() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Management::clear_election() {
  if (election_ != NULL) election_->::LeaderElection::Clear();
  clear_has_election();
}
inline const ::LeaderElection& Management::election() const {
  return election_ != NULL ? *election_ : *default_instance_->election_;
}
inline ::LeaderElection* Management::mutable_election() {
  set_has_election();
  if (election_ == NULL) election_ = new ::LeaderElection;
  return election_;
}
inline ::LeaderElection* Management::release_election() {
  clear_has_election();
  ::LeaderElection* temp = election_;
  election_ = NULL;
  return temp;
}
inline void Management::set_allocated_election(::LeaderElection* election) {
  delete election_;
  election_ = election;
  if (election) {
    set_has_election();
  } else {
    clear_has_election();
  }
}

// optional .JobProposal job_propose = 4;
inline bool Management::has_job_propose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Management::set_has_job_propose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Management::clear_has_job_propose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Management::clear_job_propose() {
  if (job_propose_ != NULL) job_propose_->::JobProposal::Clear();
  clear_has_job_propose();
}
inline const ::JobProposal& Management::job_propose() const {
  return job_propose_ != NULL ? *job_propose_ : *default_instance_->job_propose_;
}
inline ::JobProposal* Management::mutable_job_propose() {
  set_has_job_propose();
  if (job_propose_ == NULL) job_propose_ = new ::JobProposal;
  return job_propose_;
}
inline ::JobProposal* Management::release_job_propose() {
  clear_has_job_propose();
  ::JobProposal* temp = job_propose_;
  job_propose_ = NULL;
  return temp;
}
inline void Management::set_allocated_job_propose(::JobProposal* job_propose) {
  delete job_propose_;
  job_propose_ = job_propose;
  if (job_propose) {
    set_has_job_propose();
  } else {
    clear_has_job_propose();
  }
}

// optional .JobBid job_bid = 5;
inline bool Management::has_job_bid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Management::set_has_job_bid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Management::clear_has_job_bid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Management::clear_job_bid() {
  if (job_bid_ != NULL) job_bid_->::JobBid::Clear();
  clear_has_job_bid();
}
inline const ::JobBid& Management::job_bid() const {
  return job_bid_ != NULL ? *job_bid_ : *default_instance_->job_bid_;
}
inline ::JobBid* Management::mutable_job_bid() {
  set_has_job_bid();
  if (job_bid_ == NULL) job_bid_ = new ::JobBid;
  return job_bid_;
}
inline ::JobBid* Management::release_job_bid() {
  clear_has_job_bid();
  ::JobBid* temp = job_bid_;
  job_bid_ = NULL;
  return temp;
}
inline void Management::set_allocated_job_bid(::JobBid* job_bid) {
  delete job_bid_;
  job_bid_ = job_bid;
  if (job_bid) {
    set_has_job_bid();
  } else {
    clear_has_job_bid();
  }
}

// -------------------------------------------------------------------

// SignUp

// required string email = 1;
inline bool SignUp::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignUp::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignUp::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignUp::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& SignUp::email() const {
  return *email_;
}
inline void SignUp::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void SignUp::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void SignUp::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignUp::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* SignUp::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignUp::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool SignUp::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignUp::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignUp::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignUp::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SignUp::password() const {
  return *password_;
}
inline void SignUp::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SignUp::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SignUp::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignUp::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SignUp::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignUp::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string fname = 3;
inline bool SignUp::has_fname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignUp::set_has_fname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignUp::clear_has_fname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignUp::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& SignUp::fname() const {
  return *fname_;
}
inline void SignUp::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void SignUp::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void SignUp::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignUp::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* SignUp::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignUp::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string lname = 4;
inline bool SignUp::has_lname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignUp::set_has_lname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignUp::clear_has_lname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignUp::clear_lname() {
  if (lname_ != &::google::protobuf::internal::kEmptyString) {
    lname_->clear();
  }
  clear_has_lname();
}
inline const ::std::string& SignUp::lname() const {
  return *lname_;
}
inline void SignUp::set_lname(const ::std::string& value) {
  set_has_lname();
  if (lname_ == &::google::protobuf::internal::kEmptyString) {
    lname_ = new ::std::string;
  }
  lname_->assign(value);
}
inline void SignUp::set_lname(const char* value) {
  set_has_lname();
  if (lname_ == &::google::protobuf::internal::kEmptyString) {
    lname_ = new ::std::string;
  }
  lname_->assign(value);
}
inline void SignUp::set_lname(const char* value, size_t size) {
  set_has_lname();
  if (lname_ == &::google::protobuf::internal::kEmptyString) {
    lname_ = new ::std::string;
  }
  lname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignUp::mutable_lname() {
  set_has_lname();
  if (lname_ == &::google::protobuf::internal::kEmptyString) {
    lname_ = new ::std::string;
  }
  return lname_;
}
inline ::std::string* SignUp::release_lname() {
  clear_has_lname();
  if (lname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lname_;
    lname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignUp::set_allocated_lname(::std::string* lname) {
  if (lname_ != &::google::protobuf::internal::kEmptyString) {
    delete lname_;
  }
  if (lname) {
    set_has_lname();
    lname_ = lname;
  } else {
    clear_has_lname();
    lname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NameValueSet_NodeType>() {
  return ::NameValueSet_NodeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JobDesc_JobCode>() {
  return ::JobDesc_JobCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NameSpaceOperation_SpaceAction>() {
  return ::NameSpaceOperation_SpaceAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JobOperation_JobAction>() {
  return ::JobOperation_JobAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Header_Routing>() {
  return ::Header_Routing_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Network_NetworkAction>() {
  return ::Network_NetworkAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LeaderElection_VoteAction>() {
  return ::LeaderElection_VoteAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PokeStatus>() {
  return ::PokeStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
